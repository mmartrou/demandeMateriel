{% extends "base.html" %}

{% block title %}√âditeur de Planning Interactif{% endblock %}

{% block extra_css %}
<style>
    .planning-editor {
        max-width: 100%;
        overflow-x: auto;
    }
    
    /* Layout type Excel avec CSS Grid */
    .planning-grid {
        display: grid;
        grid-template-columns: 80px repeat(9, minmax(100px, 1fr));
        gap: 1px;
        width: 100%;
        font-size: 0.85em;
        margin: 20px 0;
        background-color: #dee2e6;
        min-width: 800px;
    }
    
    .grid-header {
        display: contents;
    }
    
    .time-header {
        background: #6c757d;
        color: white;
        text-align: center;
        padding: 12px 8px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        position: sticky;
        left: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .room-header-cell {
        background: #007bff;
        color: white;
        text-align: center;
        padding: 12px 4px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        font-size: 1.1em;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .grid-row {
        display: contents;
    }
    
    .time-cell {
        background: #f8f9fa;
        text-align: center;
        padding: 8px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        position: sticky;
        left: 0;
        z-index: 25;
        height: 27px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .room-cell {
        border: 1px solid #dee2e6;
        padding: 2px;
        height: 27px;
        background: #fff;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 2px;
        /* Permettre aux cours de d√©border avec position absolute */
        overflow: visible;
    }
    
    .room-cell > .course-card {
        display: block !important;
        margin-bottom: 2px;
    }
    
    .room-column {
        border: 2px solid #dee2e6;
        border-radius: 8px;
        margin-bottom: 20px;
        background-color: #f8f9fa;
        min-height: 400px;
        display: none; /* Masquer l'ancien layout */
    }
    
    .room-header {
        background-color: #007bff;
        color: white;
        padding: 15px;
        border-radius: 6px 6px 0 0;
        font-weight: bold;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .room-content {
        padding: 15px;
        min-height: 350px;
    }
    
    .time-slot-group {
        margin-bottom: 15px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        background-color: white;
    }
    
    .time-slot-header {
        background-color: #e9ecef;
        padding: 8px 12px;
        font-weight: bold;
        color: #495057;
        border-bottom: 1px solid #dee2e6;
    }
    
    .time-slot-courses {
        padding: 10px;
        min-height: 60px;
    }
    
    .course-card {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border-radius: 4px;
        padding: 4px 6px;
        margin: 1px;
        cursor: move;
        font-size: 1.35em;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: center;
        border: 2px solid rgba(255,255,255,0.3);
        /* Positionn√© par CSS Grid pour s'√©taler pr√©cis√©ment selon la dur√©e */
        align-self: stretch;
        width: calc(100% - 6px);
        overflow: hidden;
        z-index: 10;
        /* Emp√™cher le d√©bordement sur les autres colonnes */
        justify-self: stretch;
        text-align: center;
        line-height: 1.1;
        width: 100%;
        box-sizing: border-box;
    }
    
    .course-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .course-card.dragging {
        opacity: 0.6;
        transform: rotate(5deg);
        z-index: 1000;
    }
    
    .course-card .course-title {
        font-weight: bold;
        margin-bottom: 1px;
        font-size: 0.85em;
        line-height: 1;
    }
    
    .course-card .course-level {
        font-size: 0.75em;
        opacity: 0.9;
        line-height: 1;
    }
    
    .course-card .course-teacher {
        font-size: 0.7em;
        opacity: 0.8;
        margin-top: 1px;
        line-height: 1;
    }
    
    .course-card.physics {
        background: linear-gradient(135deg, #28a745, #1e7e34);
    }
    
    .course-card.chemistry {
        background: linear-gradient(135deg, #dc3545, #c82333);
    }
    
    .course-card.other {
        background: linear-gradient(135deg, #ffc107, #e0a800);
        color: #212529;
    }
    
    .drop-zone {
        min-height: 60px;
        background-color: transparent;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        padding: 5px;
        transition: all 0.3s ease;
    }
    
    /* S'assurer que les cellules vides sont visibles */
    .room-cell.drop-zone {
        min-height: 27px !important;
        border: 2px solid #007bff !important;
        background-color: #e3f2fd !important;
    }
    

    
    /* D√©filement horizontal pour les √©crans √©troits */
    .table-responsive {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
    }
    
    .table-responsive .planning-grid {
        margin-bottom: 0;
    }
    
    .drop-zone.drag-over {
        border-color: #007bff;
        background-color: #e3f2fd;
    }
    
    .drop-zone:empty::before {
        content: "Glisser un cours ici";
        color: #6c757d;
        font-style: italic;
        align-self: center;
        width: 100%;
        text-align: center;
    }
    
    .stats-panel {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .stat-item {
        display: inline-block;
        margin-right: 20px;
        padding: 8px 12px;
        background-color: white;
        border-radius: 5px;
        border-left: 4px solid #007bff;
    }
    
    .stat-item.warning {
        border-left-color: #ffc107;
    }
    
    .stat-item.error {
        border-left-color: #dc3545;
    }
    
    .controls-panel {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .legend {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
    }
    
    .legend-color.physics {
        background: linear-gradient(135deg, #28a745, #1e7e34);
    }
    
    .legend-color.chemistry {
        background: linear-gradient(135deg, #dc3545, #c82333);
    }
    
    .legend-color.other {
        background: linear-gradient(135deg, #ffc107, #e0a800);
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    
    .loading-content {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        text-align: center;
    }
    
    .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    
    @media (max-width: 768px) {
        .planning-editor {
            font-size: 0.8em;
        }
        
        .planning-grid th,
        .planning-grid td {
            min-width: 80px;
            padding: 4px;
        }
        
        .course-card {
            min-height: 40px;
            font-size: 0.7em;
        }
        
        .controls-panel {
            padding: 10px;
        }
        
        .stat-item {
            display: block;
            margin-right: 0;
            margin-bottom: 10px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2><i class="fas fa-calendar-alt"></i> √âditeur de Planning Interactif</h2>
                <div>
                    <button type="button" class="btn btn-outline-secondary me-2" onclick="resetPlanning()">
                        <i class="fas fa-undo"></i> R√©initialiser
                    </button>
                    <a href="/admin" class="btn btn-secondary me-2">
                        <i class="fas fa-arrow-left"></i> Retour Admin
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panneau de contr√¥les -->
    <div class="controls-panel">
        <div class="row">
            <div class="col-md-6">
                <h5>Configuration du jour</h5>
                <div class="row">
                    <div class="col-6">
                        <label for="target-date" class="form-label">Date du planning:</label>
                        <input type="date" id="target-date" class="form-control" required>
                    </div>
                    <div class="col-6 d-flex align-items-end">
                        <button type="button" class="btn btn-primary" onclick="loadPlanningData()">
                            <i class="fas fa-cogs"></i> G√©n√©rer et √âditer le Planning
                        </button>
                    </div>
                </div>
                <small class="text-muted">Le planning sera g√©n√©r√© automatiquement par OR-Tools puis affich√© pour √©dition manuelle.</small>
            </div>
            <div class="col-md-6">
                <h5>Actions</h5>
                <button type="button" class="btn btn-success" onclick="generateFinalPlanning()" id="generate-btn">
                    <i class="fas fa-file-excel"></i> G√©n√©rer Planning Excel Final
                </button>
                <button type="button" class="btn btn-info" onclick="reloadPlanning()">
                    <i class="fas fa-sync"></i> Recharger le Planning
                </button>
                <button type="button" class="btn btn-warning" onclick="savePlanningData()">
                    <i class="fas fa-save"></i> Enregistrer le Planning
                </button>
                <div class="legend mt-2">
                    <strong>L√©gende:</strong>
                    <div class="legend-item">
                        <div class="legend-color physics"></div>
                        <span>Physique</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color chemistry"></div>
                        <span>Chimie</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color other"></div>
                        <span>Autre</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panneau de statistiques -->
    <div class="stats-panel" id="stats-panel" style="display: none;">
        <h5>Statistiques du Planning</h5>
        <div id="stats-content">
            <!-- Les statistiques seront charg√©es ici -->
        </div>
    </div>
    
    <!-- Zone d'√©dition du planning par salle -->
    <div class="planning-editor">
        <div class="row" id="rooms-container">
            <!-- Les salles seront g√©n√©r√©es dynamiquement -->
        </div>
    </div>
    
    <!-- Message quand aucun planning n'est charg√© -->
    <div id="no-planning-message" class="text-center py-5">
        <i class="fas fa-calendar-plus fa-3x text-muted mb-3"></i>
        <h4 class="text-muted">Aucun planning charg√©</h4>
        <p class="text-muted">S√©lectionnez une date et cliquez sur "G√©n√©rer et √âditer le Planning" pour que OR-Tools optimise automatiquement les assignations de salles.</p>
        <p class="text-muted">Vous pourrez ensuite modifier manuellement le planning avant l'export Excel.</p>
    </div>

    <!-- Conteneur pour le planning g√©n√©r√© -->
    <div id="planningContainer"></div>

    <!-- Conteneur pour afficher l'√©tat de chargement -->
    <div id="loading-container"></div>
</div>

<!-- Overlay de chargement -->
<div id="loading-overlay" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="spinner-border text-primary" role="status"></div>
        <h5 class="mt-3">Chargement en cours...</h5>
        <p class="text-muted mb-0" id="loading-message">G√©n√©ration du planning initial...</p>
    </div>
</div>

<!-- Conteneur pour les alertes -->
<div id="alert-container" class="position-fixed top-0 start-50 translate-middle-x mt-3" style="z-index: 1050; width: 50%;"></div>
{% endblock %}

{% block extra_js %}
<script>
    let planningData = null;
    let currentAssignments = {};
    let currentRoomAssignments = {};
    let draggedElement = null;
    let originalPosition = null;
    
    // Initialiser la date par d√©faut (aujourd'hui)
    document.addEventListener('DOMContentLoaded', function() {
        const today = new Date();
        document.getElementById('target-date').value = today.toISOString().split('T')[0];
    });
    
    // Charger les donn√©es du planning
    async function loadPlanningData() {
        const targetDate = document.getElementById('target-date').value;
        
        if (!targetDate) {
            showAlert('Veuillez s√©lectionner une date.', 'warning');
            return;
        }
        
        showLoading('loading-container');
        
        try {
            console.log('üîÑ Appel API avec date:', targetDate);
            const response = await fetch(`/api/planning-editor/data?date=${targetDate}`);
            console.log('üì° R√©ponse API status:', response.status);
            const data = await response.json();
            console.log('üìã Donn√©es re√ßues:', data);
            
            if (response.ok) {
                planningData = data;
                currentAssignments = { ...data.assignments };
                currentRoomAssignments = { ...data.room_assignments || {} };
                
                // Debug des donn√©es re√ßues
        console.log('üìä DEBUG - Donn√©es re√ßues:', {
            courses: data.courses?.length || 0,
            room_assignments: Object.keys(data.room_assignments || {}).length,
            rooms: data.rooms?.length || 0,
            room_names: data.rooms?.map(r => r.name)
        });
        
        // Debug complet des assignations
        console.log('üîç TOUTES les assignations:', data.room_assignments);
        console.log('üîç TOUS les cours avec temps:', data.courses.map(c => ({id: c.id, teacher: c.teacher, time: c.time, assignedRoom: data.room_assignments[c.id]})));
        
        // APPELER renderPlanningGrid() maintenant avec les donn√©es de test
        console.log('üé® Appel renderPlanningGrid()');
        renderPlanningGrid();
        updateStats();
                document.getElementById('generate-btn').disabled = false;
                showAlert('Planning g√©n√©r√© et pr√™t √† √©diter!', 'success');
            } else {
                throw new Error(data.error || 'Erreur lors de la g√©n√©ration');
            }
        } catch (error) {
            console.error('Erreur:', error);
            showAlert(`Erreur lors de la g√©n√©ration: ${error.message}`, 'danger');
        } finally {
            hideLoading('loading-container');
        }
    }
    
    // Afficher le planning en grille type Excel
    function renderPlanningGrid() {
        console.log('üé® renderPlanningGrid() appel√©e, planningData:', planningData);
        if (!planningData) {
            console.log('‚ùå Pas de planningData, arr√™t');
            return;
        }
        
        const container = document.getElementById('rooms-container');
        console.log('üì¶ Container trouv√©:', container);
        
        // IMPORTANT: R√©initialiser compl√®tement le container pour √©viter les cours fant√¥mes
        console.log('üßπ Nettoyage du container avant re-rendu');
        container.innerHTML = '';
        container.className = 'table-responsive'; // Ajouter classe responsive pour d√©filement horizontal
        
        const rooms = planningData.rooms;
        console.log('üîç DEBUG: planningData structure:', Object.keys(planningData));
        console.log('üîç DEBUG: rooms variable:', rooms);
        console.log('üîç DEBUG: rooms type:', typeof rooms);
        console.log('üîç DEBUG: rooms is array?', Array.isArray(rooms));
        
        // G√©n√©rer tous les cr√©neaux de 15 minutes de 9h00 √† 18h15 c√¥t√© client
        const timeSlots = generateAllTimeSlots();
        
        console.log('üè¢ Salles disponibles:', rooms);
        console.log('‚è∞ Cr√©neaux horaires complets (15min):', timeSlots);
        console.log('üìä Total cr√©neaux:', timeSlots.length);
        
        // Cr√©er la grille principale
        const grid = document.createElement('div');
        grid.className = 'planning-grid';
        console.log('üìã Grille cr√©√©e:', grid);
        
        // En-t√™te avec les noms des salles
        const headerRow = document.createElement('div');
        headerRow.className = 'grid-header';
        
        // Cellule vide pour l'angle
        const cornerCell = document.createElement('div');
        cornerCell.className = 'time-header';
        cornerCell.textContent = 'Horaire';
        headerRow.appendChild(cornerCell);
        
        // En-t√™tes des salles
        rooms.forEach(room => {
            const roomHeaderCell = document.createElement('div');
            roomHeaderCell.className = 'room-header-cell';
            roomHeaderCell.textContent = room.name;
            headerRow.appendChild(roomHeaderCell);
        });
        
        grid.appendChild(headerRow);
        
        // Debug des correspondances IDs
        console.log('üîç Premiers cours (IDs):', planningData.courses.slice(0, 3).map(c => ({id: c.id, teacher: c.teacher, subject: c.subject})));
        console.log('üîç Room assignments (cl√©s):', Object.keys(currentRoomAssignments).slice(0, 5));
        console.log('üîç currentRoomAssignments complet:', currentRoomAssignments);
        console.log('üîç Correspondance ID cours 0:', {
            courseId: planningData.courses[0]?.id,
            assignment: currentRoomAssignments[planningData.courses[0]?.id]
        });
        
        // Compteur de placement des cours
        let totalCoursesPlaced = 0;
        let placementByRoom = {};
        rooms.forEach(room => placementByRoom[room.name] = 0);
        
        // Cr√©er une ligne pour chaque cr√©neau horaire (cellules vides pour la grille)
        timeSlots.forEach((slot, slotIndex) => {
            const row = document.createElement('div');
            row.className = 'grid-row';
            
            // Cellule de l'horaire
            const timeCell = document.createElement('div');
            timeCell.className = 'time-cell';
            timeCell.textContent = slot;
            row.appendChild(timeCell);
            
            // Cellules vides pour chaque salle (les cours seront positionn√©s par CSS Grid)
            rooms.forEach((room, roomIndex) => {
                const roomCell = document.createElement('div');
                roomCell.className = 'room-cell drop-zone';
                roomCell.dataset.room = room.name;
                roomCell.dataset.slot = slot;
                roomCell.dataset.slotIndex = slotIndex;
                roomCell.dataset.roomIndex = roomIndex;
                
                // Configurer les √©v√©nements de drop
                setupDropZone(roomCell);
                
                row.appendChild(roomCell);
            });
            
            grid.appendChild(row);
        });

        // Placer les cours dans leurs cellules de d√©but avec d√©bordement contr√¥l√©
        planningData.courses.forEach(course => {
            const assignedRoom = currentRoomAssignments[course.id];
            if (!assignedRoom) return;
            
            // Trouver l'index du cr√©neau de d√©but
            const startSlotIndex = timeSlots.findIndex(slot => slot === course.time);
            if (startSlotIndex === -1) {
                console.warn(`‚ö†Ô∏è Cr√©neau introuvable pour ${course.time}`, timeSlots);
                return;
            }
            
            // Trouver l'index de la salle
            const roomIndex = rooms.findIndex(room => room.name === assignedRoom);
            if (roomIndex === -1) return;
            
            // Trouver la cellule de d√©part
            const startCell = grid.querySelector(`[data-slot="${course.time}"][data-room="${assignedRoom}"]`);
            if (!startCell) {
                console.warn(`‚ö†Ô∏è Cellule introuvable pour ${course.time} - ${assignedRoom}`);
                return;
            }
            
            // Cr√©er le cours avec d√©bordement sur plusieurs cellules
            const courseCard = createCourseCardWithOverflow(course, startSlotIndex, timeSlots);
            
            // L'ajouter √† la cellule de d√©part
            startCell.appendChild(courseCard);
            
            totalCoursesPlaced++;
            placementByRoom[assignedRoom]++;
        });
        
        container.appendChild(grid);
        console.log('‚úÖ Grille ajout√©e au container');
        
        // Debug du placement final
        console.log('üìä PLACEMENT FINAL:', {
            totalCoursesPlaced: totalCoursesPlaced,
            placementByRoom: placementByRoom,
            totalCoursesExpected: planningData.courses.length
        });
        
        // Masquer le message "aucun planning"
        const noMsg = document.getElementById('no-planning-message');
        const statsPanel = document.getElementById('stats-panel');
        console.log('üé≠ Masquage du message "aucun planning", √©l√©ments:', noMsg, statsPanel);
        
        if (noMsg) noMsg.style.display = 'none';
        if (statsPanel) statsPanel.style.display = 'block';
        
        console.log('‚úÖ renderPlanningGrid() termin√© avec succ√®s');
    }
    
    // Cr√©er une carte de cours
    function createCourseCard(course, startSlotIndex, timeSlots) {
        const card = document.createElement('div');
        card.className = `course-card ${getCourseType(course.subject)}`;
        card.draggable = true;
        card.dataset.courseId = course.id;
        
        // Calculer la position de fin pr√©cise du cours
        const durationInMinutes = typeof course.duration === 'number' ? course.duration : parseDurationToMinutes(course.duration || 85);
        const endSlotPosition = calculateEndSlotPosition(startSlotIndex, durationInMinutes);
        
        // Utiliser CSS Grid pour positionner et √©tendre le cours
        // +2 car nous avons une ligne d'en-t√™te (index 1), les cr√©neaux commencent √† l'index 2
        const gridRowStart = startSlotIndex + 2;
        const gridRowEnd = endSlotPosition + 2;
        
        card.style.gridRowStart = gridRowStart;
        card.style.gridRowEnd = gridRowEnd;
        card.style.zIndex = '10';
        
        // Formatage de la dur√©e pour affichage
        const durationText = course.duration ? formatDuration(course.duration) : '';
        
        // Construire la liste des √©quipements sp√©cifiques
        const equipments = [];
        if (course.ordinateurs > 0) equipments.push(`üíª ${course.ordinateurs} PC`);
        if (course.eviers > 0) equipments.push(`üö∞ ${course.eviers} √©viers`);
        if (course.hotte > 0) equipments.push(`üå¨Ô∏è Hotte`);
        if (course.bancs_optiques > 0) equipments.push(`üî¨ Bancs opt.`);
        if (course.oscilloscopes > 0) equipments.push(`üìä Oscillo.`);
        if (course.becs_electriques > 0) equipments.push(`üî• Becs √©lec.`);
        if (course.support_filtration > 0) equipments.push(`‚öóÔ∏è Filtration`);
        if (course.imprimante > 0) equipments.push(`üñ®Ô∏è Imprimante`);
        if (course.examen > 0) equipments.push(`üìù Examen`);
        
        const equipmentLine = equipments.length > 0 ? `<div class="course-equipment" style="font-size: 0.7em; margin-top: 2px;">${equipments.join(', ')}</div>` : '';
        const requestNameLine = course.request_name ? `<div class="course-request-name" style="font-size: 0.75em; font-style: italic; margin-top: 1px; color: #555;">${course.request_name}</div>` : '';
        
        card.innerHTML = `
            <div class="course-title">${course.subject}</div>
            <div class="course-level">${course.level}</div>
            <div class="course-teacher">${course.teacher}</div>
            <div class="course-time">${course.time}${durationText ? ` (${durationText})` : ''}</div>
            ${requestNameLine}
            ${equipmentLine}
        `;
        
        console.log(`üìÖ Cours ${course.subject} - Grid: lignes ${gridRowStart} √† ${gridRowEnd} (${durationInMinutes}min)`);
        
        // Ajouter les √©v√©nements de drag
        setupDragEvents(card);
        
        return card;
    }

    // Cr√©er une carte de cours avec d√©bordement contr√¥l√©
    function createCourseCardWithOverflow(course, startSlotIndex, timeSlots) {
        const card = document.createElement('div');
        card.className = `course-card ${getCourseType(course.subject)}`;
        card.draggable = true;
        card.dataset.courseId = course.id;
        
        // Calculer la dur√©e en minutes
        const durationInMinutes = typeof course.duration === 'number' ? course.duration : parseDurationToMinutes(course.duration || 85);
        
        // Calculer dynamiquement la hauteur r√©elle d'une cellule
        const cellHeight = getCellHeight();
        // Calculer la hauteur exacte strictement proportionnelle √† la dur√©e
        let exactHeight = (durationInMinutes / 15) * cellHeight;

        // Utiliser position absolute pour d√©border sur les cellules suivantes
        card.style.position = 'absolute';
        card.style.top = '1px';
        card.style.left = '1px';
        card.style.right = '1px';
        card.style.height = `${exactHeight}px`;
        card.style.zIndex = '10';
        
        // Formatage de la dur√©e pour affichage
        const durationText = course.duration ? formatDuration(course.duration) : '';

        // Supprimer les mots "chimie", "physique" ou "mixte" du sujet
        const filteredSubject = course.subject.replace(/\b(chimie|physique|mixte)\b/gi, '').trim();

        // Construire la liste des √©quipements sp√©cifiques
        const equipments = [];
        if (course.ordinateurs > 0) equipments.push(`üíª ${course.ordinateurs} PC`);
        if (course.eviers > 0) equipments.push(`üö∞ ${course.eviers} √©viers`);
        if (course.hotte > 0) equipments.push(`üå¨Ô∏è Hotte`);
        if (course.bancs_optiques > 0) equipments.push(`üî¨ Bancs opt.`);
        if (course.oscilloscopes > 0) equipments.push(`üìä Oscillo.`);
        if (course.becs_electriques > 0) equipments.push(`üî• Becs √©lec.`);
        if (course.support_filtration > 0) equipments.push(`‚öóÔ∏è Filtration`);
        if (course.imprimante > 0) equipments.push(`üñ®Ô∏è Imprimante`);
        if (course.examen > 0) equipments.push(`üìù Examen`);
        
        const equipmentLine = equipments.length > 0 ? `<div class="course-equipment" style="font-size: 0.7em; margin-top: 2px;">${equipments.join(', ')}</div>` : '';
        const requestNameLine = course.request_name ? `<div class="course-request-name" style="font-size: 0.75em; font-style: italic; margin-top: 1px; color: #555;">${course.request_name}</div>` : '';

        card.innerHTML = `
            <div class="course-title">${filteredSubject}</div>
            <div class="course-level">${course.level}</div>
            <div class="course-teacher">${course.teacher}</div>
            <div class="course-time">${course.time}${durationText ? ` (${durationText})` : ''}</div>
            ${requestNameLine}
            ${equipmentLine}
        `;
        
        console.log(`üìÖ Cours ${course.subject} - Hauteur: ${exactHeight}px (${durationInMinutes}min)`);
        
        // Ajouter les √©v√©nements de drag
        setupDragEvents(card);
        
        return card;
    }
    
    // Calculer la hauteur d'un cours bas√©e sur sa dur√©e
    function calculateCourseHeight(duration) {
        // Syst√®me de hauteur proportionnelle √† la dur√©e r√©elle
        // Base : 40px pour 55min (cours le plus court)
        // √âchelle : 55min=40px, 85min=60px, 110min=80px
        const baseHeight = 40; // pixels pour 55 minutes (cours le plus court)
        const baseDuration = 55; // minutes (cours le plus court)
        
        // Convertir la dur√©e en minutes si n√©cessaire
        let durationInMinutes = duration;
        if (typeof duration === 'string') {
            // Parser la dur√©e si c'est une cha√Æne (ex: "1h30", "90min", "1.5h")
            durationInMinutes = parseDurationToMinutes(duration);
        }
        
        // Calculer la hauteur proportionnelle avec un facteur d'√©chelle l√©g√®rement r√©duit
        const scaleFactor = 0.7; // Pour √©viter des cours trop hauts
        const rawHeight = (durationInMinutes / baseDuration) * baseHeight;
        const calculatedHeight = Math.max(35, Math.min(120, rawHeight * scaleFactor));
        
        console.log(`üìè Dur√©e: ${duration} (${durationInMinutes}min) -> Hauteur: ${Math.round(calculatedHeight)}px`);
        return Math.round(calculatedHeight);
    }
    
    // Mesurer dynamiquement la hauteur r√©elle des lignes de la grille
    function getCellHeight() {
        // Chercher une ligne de la grille (grid-row) existante pour mesurer sa hauteur r√©elle
        const gridRow = document.querySelector('.grid-row .time-cell');
        if (gridRow) {
            const computedHeight = gridRow.getBoundingClientRect().height;
            console.log(`üìè Hauteur ligne grille mesur√©e: ${computedHeight}px`);
            return computedHeight;
        }
        
        // Alternative: mesurer une cellule room-cell si time-cell n'est pas disponible
        const roomCell = document.querySelector('.room-cell');
        if (roomCell) {
            const computedHeight = roomCell.getBoundingClientRect().height;
            console.log(`üìè Hauteur cellule salle mesur√©e: ${computedHeight}px`);
            return computedHeight;
        }
        
        // Valeur de fallback si aucune cellule n'est trouv√©e
        console.log('üìè Hauteur cellule fallback: 27px');
        return 27; // Correspond au min-height du CSS
    }

    // Recalculer la hauteur des cours lors du redimensionnement
    function updateCourseHeights() {
        const courseCards = document.querySelectorAll('.course-card');
        const newCellHeight = getCellHeight();
        
        courseCards.forEach(card => {
            const courseId = card.dataset.courseId;
            const course = planningData?.courses?.find(c => c.id === courseId);
            if (course) {
                const durationInMinutes = typeof course.duration === 'number' ? course.duration : parseDurationToMinutes(course.duration || 85);
                const newHeight = (durationInMinutes / 15) * newCellHeight * 1.3;
                card.style.height = `${newHeight}px`;
                console.log(`üîÑ Cours ${courseId}: nouvelle hauteur ${newHeight}px`);
            }
        });
    }

    // √âv√©nement de redimensionnement de la fen√™tre
    let resizeTimeout;
    window.addEventListener('resize', () => {
        // Debounce pour √©viter trop d'appels
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (planningData) {
                console.log('üîÑ Redimensionnement d√©tect√©, recalcul des hauteurs...');
                updateCourseHeights();
            }
        }, 250);
    });

    // G√©n√©rer tous les cr√©neaux de 15 minutes de 9h00 √† 18h15
    function generateAllTimeSlots() {
        const timeSlots = [];
        const startHour = 9;
        const startMinute = 0;
        const endHour = 18;
        const endMinute = 15;
        
        let currentHour = startHour;
        let currentMinute = startMinute;
        
        while (currentHour < endHour || (currentHour === endHour && currentMinute <= endMinute)) {
            const timeSlot = `${currentHour}h${currentMinute.toString().padStart(2, '0')}`;
            timeSlots.push(timeSlot);
            
            // Incr√©menter de 15 minutes
            currentMinute += 15;
            if (currentMinute >= 60) {
                currentMinute = 0;
                currentHour += 1;
            }
        }
        
        console.log(`üìÖ Cr√©neaux g√©n√©r√©s c√¥t√© client: ${timeSlots.length} cr√©neaux`);
        console.log(`üìÖ Premiers: ${timeSlots.slice(0, 8)}`);
        console.log(`üìÖ Derniers: ${timeSlots.slice(-4)}`);
        
        return timeSlots;
    }

    // Calculer la position de fin exacte d'un cours selon sa dur√©e
    function calculateEndSlotPosition(startSlotIndex, durationInMinutes) {
        // Chaque cr√©neau = 15 minutes
        // Position de fin = position de d√©but + (dur√©e / 15)
        // Utilisation de nombres d√©cimaux pour CSS Grid (ex: 5.5 pour s'arr√™ter au milieu du 6√®me cr√©neau)
        const exactEndPosition = startSlotIndex + (durationInMinutes / 15);
        
        console.log(`üìê Position: d√©but=${startSlotIndex}, dur√©e=${durationInMinutes}min, fin=${exactEndPosition}`);
        
        return exactEndPosition;
    }

    // Calculer combien de cr√©neaux de 15min un cours doit occuper (fonction de compatibilit√©)
    function calculateSlotsNeeded(duration) {
        const durationInMinutes = typeof duration === 'number' ? duration : parseDurationToMinutes(duration);
        const slotsNeeded = Math.ceil(durationInMinutes / 15);
        console.log(`üìê Dur√©e ${duration} (${durationInMinutes}min) = ${slotsNeeded} cr√©neaux de 15min`);
        return slotsNeeded;
    }

    // Parser une dur√©e en string vers des minutes
    function parseDurationToMinutes(durationStr) {
        if (typeof durationStr === 'number') return durationStr;
        if (!durationStr) return 60; // Dur√©e par d√©faut
        
        const str = durationStr.toString().toLowerCase();
        
        // Format "XhY" ou "Xh Y" (ex: "1h30", "2h 15")
        const hoursMinutesMatch = str.match(/(\d+)h\s*(\d*)/);
        if (hoursMinutesMatch) {
            const hours = parseInt(hoursMinutesMatch[1]) || 0;
            const minutes = parseInt(hoursMinutesMatch[2]) || 0;
            return hours * 60 + minutes;
        }
        
        // Format "X.Yh" (ex: "1.5h")
        const decimalHoursMatch = str.match(/(\d+\.?\d*)h/);
        if (decimalHoursMatch) {
            const hours = parseFloat(decimalHoursMatch[1]);
            return Math.round(hours * 60);
        }
        
        // Format "Xmin" (ex: "90min")
        const minutesMatch = str.match(/(\d+)min/);
        if (minutesMatch) {
            return parseInt(minutesMatch[1]);
        }
        
        // Format num√©rique simple (assum√© en minutes)
        const numberMatch = str.match(/^(\d+)$/);
        if (numberMatch) {
            return parseInt(numberMatch[1]);
        }
        
        // Par d√©faut, retourner 60 minutes
        console.warn(`‚ö†Ô∏è Impossible de parser la dur√©e "${durationStr}", utilisation de 60min par d√©faut`);
        return 60;
    }

    // Formater une dur√©e en minutes vers une cha√Æne lisible
    function formatDuration(duration) {
        const minutes = typeof duration === 'number' ? duration : parseDurationToMinutes(duration);
        
        if (minutes < 60) {
            return `${minutes}min`;
        } else {
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            if (remainingMinutes === 0) {
                return `${hours}h`;
            } else {
                return `${hours}h${remainingMinutes.toString().padStart(2, '0')}`;
            }
        }
    }

    // Obtenir le type de cours pour le style
    function getCourseType(subject) {
        const subjectLower = subject.toLowerCase();
        if (subjectLower.includes('physique') || subjectLower.includes('physics')) {
            return 'physics';
        } else if (subjectLower.includes('chimie') || subjectLower.includes('chemistry')) {
            return 'chemistry';
        } else {
            return 'other';
        }
    }
    
    // Formater l'en-t√™te des jours
    function formatDayHeader(day) {
        const date = new Date(day);
        const dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
        const dayName = dayNames[date.getDay()];
        const dayNum = date.getDate();
        const month = date.getMonth() + 1;
        return `${dayName} ${dayNum}/${month}`;
    }
    
    // Configurer les √©v√©nements de drag pour les cours
    function setupDragEvents(card) {
        card.addEventListener('dragstart', function(e) {
            draggedElement = this;
            originalPosition = this.parentElement;
            this.classList.add('dragging');
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        });
        
        card.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            originalPosition = null;
        });
    }
    
    // Configurer les zones de drop
    function setupDropZone(cell) {
        cell.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('drag-over');
        });
        
        cell.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over');
        });
        
        cell.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            if (draggedElement) {
                const courseId = draggedElement.dataset.courseId; // Ne pas convertir en int !
                const newRoom = this.dataset.room;
                const newSlot = this.dataset.slot;
                
                console.log(`üîÑ D√©placement: ${courseId} vers ${newRoom} √† ${newSlot}`);
                
                // Mettre √† jour l'assignation de salle
                if (newRoom && courseId) {
                    currentRoomAssignments[courseId] = newRoom;
                    
                    // IMPORTANT: Mettre √† jour aussi planningData.room_assignments pour la sauvegarde
                    if (planningData && planningData.room_assignments) {
                        planningData.room_assignments[courseId] = newRoom;
                    }
                    
                    // Mettre √† jour le cours dans planningData
                    const course = planningData.courses.find(c => c.id === courseId); // Comparaison stricte
                    if (course) {
                        course.room = newRoom;
                        course.time = newSlot;
                        console.log(`‚úÖ Cours mis √† jour:`, course);
                    } else {
                        console.log(`‚ùå Cours non trouv√©: ${courseId}`);
                    }
                    
                    console.log(`üíæ Assignations mises √† jour pour sauvegarde:`, planningData.room_assignments[courseId]);
                }
                
                // Re-rendre la grille
                renderPlanningGrid();
                updateStats();
                
                showAlert(`Cours d√©plac√© vers ${newRoom} √† ${newSlot}`, 'success');
            }
        });
    }
    
    // Obtenir l'info de position √† partir de la cellule
    function getPositionFromCell(cell) {
        if (!cell || !cell.dataset) return null;
        return {
            room: cell.dataset.room,
            slot: cell.dataset.slot
        };
    }
    
    // Mettre √† jour les statistiques
    function updateStats() {
        if (!planningData) return;
        
        const statsContent = document.getElementById('stats-content');
        const totalCourses = planningData.courses.length;
        
        // Compter les cours assign√©s √† des salles
        const assignedCourses = planningData.courses.filter(c => 
            currentRoomAssignments[c.id] && currentRoomAssignments[c.id] !== 'Non assign√©'
        ).length;
        const unassignedCourses = totalCourses - assignedCourses;
        
        // D√©tecter les conflits (plusieurs cours m√™me salle m√™me heure)
        const conflicts = new Map();
        planningData.courses.forEach(course => {
            const key = `${currentRoomAssignments[course.id]}_${course.time}`;
            if (!conflicts.has(key)) {
                conflicts.set(key, []);
            }
            conflicts.get(key).push(course.id);
        });
        
        const conflictCount = Array.from(conflicts.values()).filter(courses => courses.length > 1).length;
        
        // Compter les salles utilis√©es
        const usedRooms = new Set(Object.values(currentRoomAssignments).filter(room => room !== 'Non assign√©')).size;
        
        statsContent.innerHTML = `
            <div class="stat-item">
                <strong>Cours total:</strong> ${totalCourses}
            </div>
            <div class="stat-item">
                <strong>Cours assign√©s:</strong> ${assignedCourses}
            </div>
            <div class="stat-item ${unassignedCourses > 0 ? 'warning' : ''}">
                <strong>Non assign√©s:</strong> ${unassignedCourses}
            </div>
            <div class="stat-item ${conflictCount > 0 ? 'error' : ''}">
                <strong>Conflits salle/heure:</strong> ${conflictCount}
            </div>
            <div class="stat-item">
                <strong>Salles utilis√©es:</strong> ${usedRooms}/${planningData.rooms.length}
            </div>
        `;
    }
    
    // R√©initialiser le planning
    function resetPlanning() {
        if (planningData && confirm('√ätes-vous s√ªr de vouloir r√©initialiser le planning aux assignations automatiques ?')) {
            currentAssignments = { ...planningData.assignments };
            renderPlanningGrid();
            updateStats();
            showAlert('Planning r√©initialis√©!', 'info');
        }
    }
    
    // G√©n√©rer le planning Excel final
    async function generateFinalPlanning() {
        if (!planningData) {
            showAlert('Aucun planning charg√©.', 'warning');
            return;
        }
        
        const targetDate = document.getElementById('target-date').value;
        
        showLoading('loading-container');
        
        try {
            // Cr√©er les assignments bas√©s sur les positions actuelles des cours
            const finalAssignments = {};
            planningData.courses.forEach(course => {
                const slotKey = `${planningData.days[0]}_${course.time}`;
                if (!finalAssignments[slotKey]) {
                    finalAssignments[slotKey] = [];
                }
                finalAssignments[slotKey].push(course.id);
            });
            
            const response = await fetch('/api/planning-editor/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    assignments: finalAssignments,
                    room_assignments: currentRoomAssignments,
                    date: targetDate
                })
            });
            
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `planning_personnalise_${targetDate}.xlsx`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                showAlert('Planning Excel g√©n√©r√© avec succ√®s!', 'success');
            } else {
                const data = await response.json();
                throw new Error(data.error || 'Erreur lors de la g√©n√©ration');
            }
        } catch (error) {
            console.error('Erreur:', error);
            showAlert(`Erreur lors de la g√©n√©ration: ${error.message}`, 'danger');
        } finally {
            hideLoading('loading-container');
        }
    }
    
    // Enregistrer le planning dans la base de donn√©es
    async function savePlanningData() {
        if (!planningData) {
            console.log('‚ùå Aucun planning √† enregistrer.');
            showAlert('Aucun planning √† enregistrer.', 'warning');
            return;
        }

        const targetDate = document.getElementById('target-date').value;
        const payload = {
            date: targetDate,
            data: planningData
        };

        try {
            console.log('üîÑ Envoi des donn√©es √† /api/save-planning:', payload);
            const response = await fetch('/api/save-planning', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            console.log('üì° R√©ponse API status:', response.status);
            if (response.ok) {
                showAlert('Planning enregistr√© avec succ√®s!', 'success');
            } else {
                const errorData = await response.json();
                showAlert(`Erreur: ${errorData.error}`, 'danger');
            }
        } catch (error) {
            console.error('Erreur lors de l\'enregistrement du planning:', error);
            showAlert('Erreur lors de l\'enregistrement du planning.', 'danger');
        }
    }

    // Appeler savePlanningData apr√®s la g√©n√©ration du planning
    document.getElementById('generate-btn').addEventListener('click', savePlanningData);
    
    document.getElementById('target-date').addEventListener('change', function() {
    const selectedDate = this.value;

    // Utiliser reloadPlanning() pour charger automatiquement le planning dans la grille
    if (selectedDate) {
        reloadPlanning();
    }
});

// Fonctions supprim√©es car on utilise maintenant reloadPlanning() automatiquement

// Move the reloadPlanning function definition to global scope
async function reloadPlanning() {
    const targetDate = document.getElementById('target-date').value;

    if (!targetDate) {
        showAlert('Veuillez s√©lectionner une date.', 'warning');
        return;
    }

    showLoading('loading-container');

    try {
        const response = await fetch(`/api/get-planning?date=${targetDate}`);
        if (response.ok) {
            const data = await response.json();
            console.log('üîç Raw API response:', data);
            
            // Parse the JSON string if needed
            if (typeof data.planning === 'string') {
                planningData = JSON.parse(data.planning);
            } else {
                planningData = data.planning || data;
            }
            
            // Update currentRoomAssignments with loaded data
            currentRoomAssignments = { ...planningData.room_assignments || {} };
            
            console.log('üîç Assigned planningData:', planningData);
            console.log('üîç planningData.rooms:', planningData.rooms);
            console.log('üîç Updated currentRoomAssignments:', currentRoomAssignments);
            renderPlanningGrid(); // Fonction existante pour afficher le planning
            showAlert('Planning charg√© avec succ√®s!', 'success');
        } else {
            const errorData = await response.json();
            showAlert(`Erreur: ${errorData.error}`, 'danger');
        }
    } catch (error) {
        console.error('Erreur lors du chargement du planning:', error);
        showAlert('Erreur lors du chargement du planning.', 'danger');
    } finally {
        hideLoading('loading-container');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    // Attach reloadPlanning to the window object to make it globally accessible
    window.reloadPlanning = reloadPlanning;
    console.log('reloadPlanning function attached to window:', window.reloadPlanning);
    
    // Attach savePlanningData to the window object to make it globally accessible
    window.savePlanningData = savePlanningData;
});
</script>
{% endblock %}