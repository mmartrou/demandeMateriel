{% extends "base.html" %}

{% block title %}Éditeur de Planning Interactive{% endblock %}

{% block extra_css %}
<style>
    .planning-editor {
        max-width: 100%;
        overflow-x: auto;
    }
    
    /* Layout type Excel avec CSS Grid */
    .planning-grid {
        display: grid;
        grid-template-columns: 80px repeat(9, minmax(100px, 1fr));
        gap: 1px;
        width: 100%;
        font-size: 0.85em;
        margin: 20px 0;
        background-color: #dee2e6;
        min-width: 800px;
    }
    
    .grid-header {
        display: contents;
    }
    
    .time-header {
        background: #6c757d;
        color: white;
        text-align: center;
        padding: 12px 8px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        position: sticky;
        left: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .room-header-cell {
        background: #007bff;
        color: white;
        text-align: center;
        padding: 12px 4px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        font-size: 1.1em;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .grid-row {
        display: contents;
    }
    
    .time-cell {
        background: #f8f9fa;
        text-align: center;
        padding: 8px;
        font-weight: bold;
        border: 1px solid #dee2e6;
        position: sticky;
        left: 0;
        z-index: 25;
        min-height: 27px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .room-cell {
        border: 1px solid #dee2e6;
        padding: 2px;
        min-height: 27px;
        background: #fff;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 2px;
        /* Permettre aux cours de déborder avec position absolute */
        overflow: visible;
    }
    
    .room-cell > .course-card {
        display: block !important;
        margin-bottom: 2px;
    }
    
    .room-column {
        border: 2px solid #dee2e6;
        border-radius: 8px;
        margin-bottom: 20px;
        background-color: #f8f9fa;
        min-height: 400px;
        display: none; /* Masquer l'ancien layout */
    }
    
    .room-header {
        background-color: #007bff;
        color: white;
        padding: 15px;
        border-radius: 6px 6px 0 0;
        font-weight: bold;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .room-content {
        padding: 15px;
        min-height: 350px;
    }
    
    .time-slot-group {
        margin-bottom: 15px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        background-color: white;
    }
    
    .time-slot-header {
        background-color: #e9ecef;
        padding: 8px 12px;
        font-weight: bold;
        color: #495057;
        border-bottom: 1px solid #dee2e6;
    }
    
    .time-slot-courses {
        padding: 10px;
        min-height: 60px;
    }
    
    .course-card {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border-radius: 4px;
        padding: 4px 6px;
        margin: 1px;
        cursor: move;
        font-size: 1.35em;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: center;
        border: 2px solid rgba(255,255,255,0.3);
        /* Positionné par CSS Grid pour s'étaler précisément selon la durée */
        align-self: stretch;
        width: calc(100% - 6px);
        overflow: hidden;
        z-index: 10;
        /* Empêcher le débordement sur les autres colonnes */
        justify-self: stretch;
        text-align: center;
        line-height: 1.1;
        width: 100%;
        box-sizing: border-box;
    }
    
    .course-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .course-card.dragging {
        opacity: 0.6;
        transform: rotate(5deg);
        z-index: 1000;
    }
    
    .course-card .course-title {
        font-weight: bold;
        margin-bottom: 1px;
        font-size: 0.85em;
        line-height: 1;
    }
    
    .course-card .course-level {
        font-size: 0.75em;
        opacity: 0.9;
        line-height: 1;
    }
    
    .course-card .course-teacher {
        font-size: 0.7em;
        opacity: 0.8;
        margin-top: 1px;
        line-height: 1;
    }
    
    .course-card.physics {
        background: linear-gradient(135deg, #28a745, #1e7e34);
    }
    
    .course-card.chemistry {
        background: linear-gradient(135deg, #dc3545, #c82333);
    }
    
    .course-card.other {
        background: linear-gradient(135deg, #ffc107, #e0a800);
        color: #212529;
    }
    
    .drop-zone {
        min-height: 60px;
        background-color: transparent;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        padding: 5px;
        transition: all 0.3s ease;
    }
    
    /* S'assurer que les cellules vides sont visibles */
    .room-cell.drop-zone {
        min-height: 27px !important;
        border: 2px solid #007bff !important;
        background-color: #e3f2fd !important;
    }
    

    
    /* Défilement horizontal pour les écrans étroits */
    .table-responsive {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
    }
    
    .table-responsive .planning-grid {
        margin-bottom: 0;
    }
    
    .drop-zone.drag-over {
        border-color: #007bff;
        background-color: #e3f2fd;
    }
    
    .drop-zone:empty::before {
        content: "Glisser un cours ici";
        color: #6c757d;
        font-style: italic;
        align-self: center;
        width: 100%;
        text-align: center;
    }
    
    .stats-panel {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .stat-item {
        display: inline-block;
        margin-right: 20px;
        padding: 8px 12px;
        background-color: white;
        border-radius: 5px;
        border-left: 4px solid #007bff;
    }
    
    .stat-item.warning {
        border-left-color: #ffc107;
    }
    
    .stat-item.error {
        border-left-color: #dc3545;
    }
    
    .controls-panel {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .legend {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 10px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
    }
    
    .legend-color.physics {
        background: linear-gradient(135deg, #28a745, #1e7e34);
    }
    
    .legend-color.chemistry {
        background: linear-gradient(135deg, #dc3545, #c82333);
    }
    
    .legend-color.other {
        background: linear-gradient(135deg, #ffc107, #e0a800);
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    
    .loading-content {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        text-align: center;
    }
    
    .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    
    @media (max-width: 768px) {
        .planning-editor {
            font-size: 0.8em;
        }
        
        .planning-grid th,
        .planning-grid td {
            min-width: 80px;
            padding: 4px;
        }
        
        .course-card {
            min-height: 40px;
            font-size: 0.7em;
        }
        
        .controls-panel {
            padding: 10px;
        }
        
        .stat-item {
            display: block;
            margin-right: 0;
            margin-bottom: 10px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2><i class="fas fa-calendar-alt"></i> Éditeur de Planning Interactive</h2>
                <div>
                    <button type="button" class="btn btn-outline-secondary me-2" onclick="resetPlanning()">
                        <i class="fas fa-undo"></i> Réinitialiser
                    </button>
                    <a href="/admin" class="btn btn-secondary me-2">
                        <i class="fas fa-arrow-left"></i> Retour Admin
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panneau de contrôles -->
    <div class="controls-panel">
        <div class="row">
            <div class="col-md-6">
                <h5>Configuration du jour</h5>
                <div class="row">
                    <div class="col-6">
                        <label for="target-date" class="form-label">Date du planning:</label>
                        <input type="date" id="target-date" class="form-control" required>
                    </div>
                    <div class="col-6 d-flex align-items-end">
                        <button type="button" class="btn btn-primary" onclick="loadPlanningData()">
                            <i class="fas fa-cogs"></i> Générer et Éditer le Planning
                        </button>
                    </div>
                </div>
                <small class="text-muted">Le planning sera généré automatiquement par OR-Tools puis affiché pour édition manuelle.</small>
            </div>
            <div class="col-md-6">
                <h5>Actions</h5>
                <button type="button" class="btn btn-success" onclick="generateFinalPlanning()" disabled id="generate-btn">
                    <i class="fas fa-file-excel"></i> Générer Planning Excel Final
                </button>
                <div class="legend mt-2">
                    <strong>Légende:</strong>
                    <div class="legend-item">
                        <div class="legend-color physics"></div>
                        <span>Physique</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color chemistry"></div>
                        <span>Chimie</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color other"></div>
                        <span>Autre</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panneau de statistiques -->
    <div class="stats-panel" id="stats-panel" style="display: none;">
        <h5>Statistiques du Planning</h5>
        <div id="stats-content">
            <!-- Les statistiques seront chargées ici -->
        </div>
    </div>
    
    <!-- Zone d'édition du planning par salle -->
    <div class="planning-editor">
        <div class="row" id="rooms-container">
            <!-- Les salles seront générées dynamiquement -->
        </div>
    </div>
    
    <!-- Message quand aucun planning n'est chargé -->
    <div id="no-planning-message" class="text-center py-5">
        <i class="fas fa-calendar-plus fa-3x text-muted mb-3"></i>
        <h4 class="text-muted">Aucun planning chargé</h4>
        <p class="text-muted">Sélectionnez une date et cliquez sur "Générer et Éditer le Planning" pour que OR-Tools optimise automatiquement les assignations de salles.</p>
        <p class="text-muted">Vous pourrez ensuite modifier manuellement le planning avant l'export Excel.</p>
    </div>
</div>

<!-- Overlay de chargement -->
<div id="loading-overlay" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="spinner-border text-primary" role="status"></div>
        <h5 class="mt-3">Chargement en cours...</h5>
        <p class="text-muted mb-0" id="loading-message">Génération du planning initial...</p>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let planningData = null;
    let currentAssignments = {};
    let currentRoomAssignments = {};
    let draggedElement = null;
    let originalPosition = null;
    
    // Initialiser la date par défaut (aujourd'hui)
    document.addEventListener('DOMContentLoaded', function() {
        const today = new Date();
        document.getElementById('target-date').value = today.toISOString().split('T')[0];
    });
    
    // Charger les données du planning
    async function loadPlanningData() {
        const targetDate = document.getElementById('target-date').value;
        
        if (!targetDate) {
            showAlert('Veuillez sélectionner une date.', 'warning');
            return;
        }
        
        showLoading('Génération du planning optimisé par OR-Tools...');
        
        try {
            console.log('🔄 Appel API avec date:', targetDate);
            const response = await fetch(`/api/planning-editor/data?date=${targetDate}`);
            console.log('📡 Réponse API status:', response.status);
            const data = await response.json();
            console.log('📋 Données reçues:', data);
            
            if (response.ok) {
                planningData = data;
                currentAssignments = { ...data.assignments };
                currentRoomAssignments = { ...data.room_assignments || {} };
                
                // Debug des données reçues
        console.log('📊 DEBUG - Données reçues:', {
            courses: data.courses?.length || 0,
            room_assignments: Object.keys(data.room_assignments || {}).length,
            rooms: data.rooms?.length || 0,
            room_names: data.rooms?.map(r => r.name)
        });
        
        // Debug complet des assignations
        console.log('🔍 TOUTES les assignations:', data.room_assignments);
        console.log('🔍 TOUS les cours avec temps:', data.courses.map(c => ({id: c.id, teacher: c.teacher, time: c.time, assignedRoom: data.room_assignments[c.id]})));
        
        // APPELER renderPlanningGrid() maintenant avec les données de test
        console.log('🎨 Appel renderPlanningGrid()');
        renderPlanningGrid();
        updateStats();
                document.getElementById('generate-btn').disabled = false;
                showAlert('Planning généré et prêt à éditer!', 'success');
            } else {
                throw new Error(data.error || 'Erreur lors de la génération');
            }
        } catch (error) {
            console.error('Erreur:', error);
            showAlert(`Erreur lors de la génération: ${error.message}`, 'danger');
        } finally {
            hideLoading();
        }
    }
    
    // Afficher le planning en grille type Excel
    function renderPlanningGrid() {
        console.log('🎨 renderPlanningGrid() appelée, planningData:', planningData);
        if (!planningData) {
            console.log('❌ Pas de planningData, arrêt');
            return;
        }
        
        const container = document.getElementById('rooms-container');
        console.log('📦 Container trouvé:', container);
        
        // IMPORTANT: Réinitialiser complètement le container pour éviter les cours fantômes
        console.log('🧹 Nettoyage du container avant re-rendu');
        container.innerHTML = '';
        container.className = 'table-responsive'; // Ajouter classe responsive pour défilement horizontal
        
        const rooms = planningData.rooms;
        
        // Générer tous les créneaux de 15 minutes de 9h00 à 18h15 côté client
        const timeSlots = generateAllTimeSlots();
        
        console.log('🏢 Salles disponibles:', rooms);
        console.log('⏰ Créneaux horaires complets (15min):', timeSlots);
        console.log('📊 Total créneaux:', timeSlots.length);
        
        // Créer la grille principale
        const grid = document.createElement('div');
        grid.className = 'planning-grid';
        console.log('📋 Grille créée:', grid);
        
        // En-tête avec les noms des salles
        const headerRow = document.createElement('div');
        headerRow.className = 'grid-header';
        
        // Cellule vide pour l'angle
        const cornerCell = document.createElement('div');
        cornerCell.className = 'time-header';
        cornerCell.textContent = 'Horaire';
        headerRow.appendChild(cornerCell);
        
        // En-têtes des salles
        rooms.forEach(room => {
            const roomHeaderCell = document.createElement('div');
            roomHeaderCell.className = 'room-header-cell';
            roomHeaderCell.textContent = room.name;
            headerRow.appendChild(roomHeaderCell);
        });
        
        grid.appendChild(headerRow);
        
        // Debug des correspondances IDs
        console.log('🔍 Premiers cours (IDs):', planningData.courses.slice(0, 3).map(c => ({id: c.id, teacher: c.teacher, subject: c.subject})));
        console.log('🔍 Room assignments (clés):', Object.keys(currentRoomAssignments).slice(0, 5));
        console.log('🔍 currentRoomAssignments complet:', currentRoomAssignments);
        console.log('🔍 Correspondance ID cours 0:', {
            courseId: planningData.courses[0]?.id,
            assignment: currentRoomAssignments[planningData.courses[0]?.id]
        });
        
        // Compteur de placement des cours
        let totalCoursesPlaced = 0;
        let placementByRoom = {};
        rooms.forEach(room => placementByRoom[room.name] = 0);
        
        // Créer une ligne pour chaque créneau horaire (cellules vides pour la grille)
        timeSlots.forEach((slot, slotIndex) => {
            const row = document.createElement('div');
            row.className = 'grid-row';
            
            // Cellule de l'horaire
            const timeCell = document.createElement('div');
            timeCell.className = 'time-cell';
            timeCell.textContent = slot;
            row.appendChild(timeCell);
            
            // Cellules vides pour chaque salle (les cours seront positionnés par CSS Grid)
            rooms.forEach((room, roomIndex) => {
                const roomCell = document.createElement('div');
                roomCell.className = 'room-cell drop-zone';
                roomCell.dataset.room = room.name;
                roomCell.dataset.slot = slot;
                roomCell.dataset.slotIndex = slotIndex;
                roomCell.dataset.roomIndex = roomIndex;
                
                // Configurer les événements de drop
                setupDropZone(roomCell);
                
                row.appendChild(roomCell);
            });
            
            grid.appendChild(row);
        });

        // Placer les cours dans leurs cellules de début avec débordement contrôlé
        planningData.courses.forEach(course => {
            const assignedRoom = currentRoomAssignments[course.id];
            if (!assignedRoom) return;
            
            // Trouver l'index du créneau de début
            const startSlotIndex = timeSlots.findIndex(slot => slot === course.time);
            if (startSlotIndex === -1) {
                console.warn(`⚠️ Créneau introuvable pour ${course.time}`, timeSlots);
                return;
            }
            
            // Trouver l'index de la salle
            const roomIndex = rooms.findIndex(room => room.name === assignedRoom);
            if (roomIndex === -1) return;
            
            // Trouver la cellule de départ
            const startCell = grid.querySelector(`[data-slot="${course.time}"][data-room="${assignedRoom}"]`);
            if (!startCell) {
                console.warn(`⚠️ Cellule introuvable pour ${course.time} - ${assignedRoom}`);
                return;
            }
            
            // Créer le cours avec débordement sur plusieurs cellules
            const courseCard = createCourseCardWithOverflow(course, startSlotIndex, timeSlots);
            
            // L'ajouter à la cellule de départ
            startCell.appendChild(courseCard);
            
            totalCoursesPlaced++;
            placementByRoom[assignedRoom]++;
        });
        
        container.appendChild(grid);
        console.log('✅ Grille ajoutée au container');
        
        // Debug du placement final
        console.log('📊 PLACEMENT FINAL:', {
            totalCoursesPlaced: totalCoursesPlaced,
            placementByRoom: placementByRoom,
            totalCoursesExpected: planningData.courses.length
        });
        
        // Masquer le message "aucun planning"
        const noMsg = document.getElementById('no-planning-message');
        const statsPanel = document.getElementById('stats-panel');
        console.log('🎭 Masquage du message "aucun planning", éléments:', noMsg, statsPanel);
        
        if (noMsg) noMsg.style.display = 'none';
        if (statsPanel) statsPanel.style.display = 'block';
        
        console.log('✅ renderPlanningGrid() terminé avec succès');
    }
    
    // Créer une carte de cours
    function createCourseCard(course, startSlotIndex, timeSlots) {
        const card = document.createElement('div');
        card.className = `course-card ${getCourseType(course.subject)}`;
        card.draggable = true;
        card.dataset.courseId = course.id;
        
        // Calculer la position de fin précise du cours
        const durationInMinutes = typeof course.duration === 'number' ? course.duration : parseDurationToMinutes(course.duration || 85);
        const endSlotPosition = calculateEndSlotPosition(startSlotIndex, durationInMinutes);
        
        // Utiliser CSS Grid pour positionner et étendre le cours
        // +2 car nous avons une ligne d'en-tête (index 1), les créneaux commencent à l'index 2
        const gridRowStart = startSlotIndex + 2;
        const gridRowEnd = endSlotPosition + 2;
        
        card.style.gridRowStart = gridRowStart;
        card.style.gridRowEnd = gridRowEnd;
        card.style.zIndex = '10';
        
        // Formatage de la durée pour affichage
        const durationText = course.duration ? formatDuration(course.duration) : '';
        
        card.innerHTML = `
            <div class="course-title">${course.subject}</div>
            <div class="course-level">${course.level}</div>
            <div class="course-teacher">${course.teacher}</div>
            <div class="course-time">${course.time}${durationText ? ` (${durationText})` : ''}</div>
        `;
        
        console.log(`📅 Cours ${course.subject} - Grid: lignes ${gridRowStart} à ${gridRowEnd} (${durationInMinutes}min)`);
        
        // Ajouter les événements de drag
        setupDragEvents(card);
        
        return card;
    }

    // Créer une carte de cours avec débordement contrôlé
    function createCourseCardWithOverflow(course, startSlotIndex, timeSlots) {
        const card = document.createElement('div');
        card.className = `course-card ${getCourseType(course.subject)}`;
        card.draggable = true;
        card.dataset.courseId = course.id;
        
        // Calculer la durée en minutes
        const durationInMinutes = typeof course.duration === 'number' ? course.duration : parseDurationToMinutes(course.duration || 85);
        
        // Calculer la hauteur d'une cellule en pixels (réduite de 80px à 27px)
        const cellHeight = 40; // Hauteur d'une cellule en pixels (réduite de 80px à 27px)
        // Calculer la hauteur exacte strictement proportionnelle à la durée
        let exactHeight = (durationInMinutes / 15) * cellHeight;

        // Utiliser position absolute pour déborder sur les cellules suivantes
        card.style.position = 'absolute';
        card.style.top = '1px';
        card.style.left = '1px';
        card.style.right = '1px';
        card.style.height = `${exactHeight}px`;
        card.style.zIndex = '10';
        
        // Formatage de la durée pour affichage
        const durationText = course.duration ? formatDuration(course.duration) : '';
        
        // Supprimer les mots "chimie", "physique" ou "mixte" du sujet
        const filteredSubject = course.subject.replace(/\b(chimie|physique|mixte)\b/gi, '').trim();

        card.innerHTML = `
            <div class="course-title">${filteredSubject}</div>
            <div class="course-level">${course.level}</div>
            <div class="course-teacher">${course.teacher}</div>
            <div class="course-time">${course.time}${durationText ? ` (${durationText})` : ''}</div>
        `;
        
        console.log(`📅 Cours ${course.subject} - Hauteur: ${exactHeight}px (${durationInMinutes}min)`);
        
        // Ajouter les événements de drag
        setupDragEvents(card);
        
        return card;
    }
    
    // Calculer la hauteur d'un cours basée sur sa durée
    function calculateCourseHeight(duration) {
        // Système de hauteur proportionnelle à la durée réelle
        // Base : 40px pour 55min (cours le plus court)
        // Échelle : 55min=40px, 85min=60px, 110min=80px
        const baseHeight = 40; // pixels pour 55 minutes (cours le plus court)
        const baseDuration = 55; // minutes (cours le plus court)
        
        // Convertir la durée en minutes si nécessaire
        let durationInMinutes = duration;
        if (typeof duration === 'string') {
            // Parser la durée si c'est une chaîne (ex: "1h30", "90min", "1.5h")
            durationInMinutes = parseDurationToMinutes(duration);
        }
        
        // Calculer la hauteur proportionnelle avec un facteur d'échelle légèrement réduit
        const scaleFactor = 0.7; // Pour éviter des cours trop hauts
        const rawHeight = (durationInMinutes / baseDuration) * baseHeight;
        const calculatedHeight = Math.max(35, Math.min(120, rawHeight * scaleFactor));
        
        console.log(`📏 Durée: ${duration} (${durationInMinutes}min) -> Hauteur: ${Math.round(calculatedHeight)}px`);
        return Math.round(calculatedHeight);
    }
    
    // Générer tous les créneaux de 15 minutes de 9h00 à 18h15
    function generateAllTimeSlots() {
        const timeSlots = [];
        const startHour = 9;
        const startMinute = 0;
        const endHour = 18;
        const endMinute = 15;
        
        let currentHour = startHour;
        let currentMinute = startMinute;
        
        while (currentHour < endHour || (currentHour === endHour && currentMinute <= endMinute)) {
            const timeSlot = `${currentHour}h${currentMinute.toString().padStart(2, '0')}`;
            timeSlots.push(timeSlot);
            
            // Incrémenter de 15 minutes
            currentMinute += 15;
            if (currentMinute >= 60) {
                currentMinute = 0;
                currentHour += 1;
            }
        }
        
        console.log(`📅 Créneaux générés côté client: ${timeSlots.length} créneaux`);
        console.log(`📅 Premiers: ${timeSlots.slice(0, 8)}`);
        console.log(`📅 Derniers: ${timeSlots.slice(-4)}`);
        
        return timeSlots;
    }

    // Calculer la position de fin exacte d'un cours selon sa durée
    function calculateEndSlotPosition(startSlotIndex, durationInMinutes) {
        // Chaque créneau = 15 minutes
        // Position de fin = position de début + (durée / 15)
        // Utilisation de nombres décimaux pour CSS Grid (ex: 5.5 pour s'arrêter au milieu du 6ème créneau)
        const exactEndPosition = startSlotIndex + (durationInMinutes / 15);
        
        console.log(`📐 Position: début=${startSlotIndex}, durée=${durationInMinutes}min, fin=${exactEndPosition}`);
        
        return exactEndPosition;
    }

    // Calculer combien de créneaux de 15min un cours doit occuper (fonction de compatibilité)
    function calculateSlotsNeeded(duration) {
        const durationInMinutes = typeof duration === 'number' ? duration : parseDurationToMinutes(duration);
        const slotsNeeded = Math.ceil(durationInMinutes / 15);
        console.log(`📐 Durée ${duration} (${durationInMinutes}min) = ${slotsNeeded} créneaux de 15min`);
        return slotsNeeded;
    }

    // Parser une durée en string vers des minutes
    function parseDurationToMinutes(durationStr) {
        if (typeof durationStr === 'number') return durationStr;
        if (!durationStr) return 60; // Durée par défaut
        
        const str = durationStr.toString().toLowerCase();
        
        // Format "XhY" ou "Xh Y" (ex: "1h30", "2h 15")
        const hoursMinutesMatch = str.match(/(\d+)h\s*(\d*)/);
        if (hoursMinutesMatch) {
            const hours = parseInt(hoursMinutesMatch[1]) || 0;
            const minutes = parseInt(hoursMinutesMatch[2]) || 0;
            return hours * 60 + minutes;
        }
        
        // Format "X.Yh" (ex: "1.5h")
        const decimalHoursMatch = str.match(/(\d+\.?\d*)h/);
        if (decimalHoursMatch) {
            const hours = parseFloat(decimalHoursMatch[1]);
            return Math.round(hours * 60);
        }
        
        // Format "Xmin" (ex: "90min")
        const minutesMatch = str.match(/(\d+)min/);
        if (minutesMatch) {
            return parseInt(minutesMatch[1]);
        }
        
        // Format numérique simple (assumé en minutes)
        const numberMatch = str.match(/^(\d+)$/);
        if (numberMatch) {
            return parseInt(numberMatch[1]);
        }
        
        // Par défaut, retourner 60 minutes
        console.warn(`⚠️ Impossible de parser la durée "${durationStr}", utilisation de 60min par défaut`);
        return 60;
    }

    // Formater une durée en minutes vers une chaîne lisible
    function formatDuration(duration) {
        const minutes = typeof duration === 'number' ? duration : parseDurationToMinutes(duration);
        
        if (minutes < 60) {
            return `${minutes}min`;
        } else {
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            if (remainingMinutes === 0) {
                return `${hours}h`;
            } else {
                return `${hours}h${remainingMinutes.toString().padStart(2, '0')}`;
            }
        }
    }

    // Obtenir le type de cours pour le style
    function getCourseType(subject) {
        const subjectLower = subject.toLowerCase();
        if (subjectLower.includes('physique') || subjectLower.includes('physics')) {
            return 'physics';
        } else if (subjectLower.includes('chimie') || subjectLower.includes('chemistry')) {
            return 'chemistry';
        } else {
            return 'other';
        }
    }
    
    // Formater l'en-tête des jours
    function formatDayHeader(day) {
        const date = new Date(day);
        const dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
        const dayName = dayNames[date.getDay()];
        const dayNum = date.getDate();
        const month = date.getMonth() + 1;
        return `${dayName} ${dayNum}/${month}`;
    }
    
    // Configurer les événements de drag pour les cours
    function setupDragEvents(card) {
        card.addEventListener('dragstart', function(e) {
            draggedElement = this;
            originalPosition = this.parentElement;
            this.classList.add('dragging');
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        });
        
        card.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            originalPosition = null;
        });
    }
    
    // Configurer les zones de drop
    function setupDropZone(cell) {
        cell.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('drag-over');
        });
        
        cell.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over');
        });
        
        cell.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            if (draggedElement) {
                const courseId = draggedElement.dataset.courseId; // Ne pas convertir en int !
                const newRoom = this.dataset.room;
                const newSlot = this.dataset.slot;
                
                console.log(`🔄 Déplacement: ${courseId} vers ${newRoom} à ${newSlot}`);
                
                // Mettre à jour l'assignation de salle
                if (newRoom && courseId) {
                    currentRoomAssignments[courseId] = newRoom;
                    
                    // Mettre à jour le cours dans planningData
                    const course = planningData.courses.find(c => c.id === courseId); // Comparaison stricte
                    if (course) {
                        course.room = newRoom;
                        course.time = newSlot;
                        console.log(`✅ Cours mis à jour:`, course);
                    } else {
                        console.log(`❌ Cours non trouvé: ${courseId}`);
                    }
                }
                
                // Re-rendre la grille
                renderPlanningGrid();
                updateStats();
                
                showAlert(`Cours déplacé vers ${newRoom} à ${newSlot}`, 'success');
            }
        });
    }
    
    // Obtenir l'info de position à partir de la cellule
    function getPositionFromCell(cell) {
        if (!cell || !cell.dataset) return null;
        return {
            room: cell.dataset.room,
            slot: cell.dataset.slot
        };
    }
    
    // Mettre à jour les statistiques
    function updateStats() {
        if (!planningData) return;
        
        const statsContent = document.getElementById('stats-content');
        const totalCourses = planningData.courses.length;
        
        // Compter les cours assignés à des salles
        const assignedCourses = planningData.courses.filter(c => 
            currentRoomAssignments[c.id] && currentRoomAssignments[c.id] !== 'Non assigné'
        ).length;
        const unassignedCourses = totalCourses - assignedCourses;
        
        // Détecter les conflits (plusieurs cours même salle même heure)
        const conflicts = new Map();
        planningData.courses.forEach(course => {
            const key = `${currentRoomAssignments[course.id]}_${course.time}`;
            if (!conflicts.has(key)) {
                conflicts.set(key, []);
            }
            conflicts.get(key).push(course.id);
        });
        
        const conflictCount = Array.from(conflicts.values()).filter(courses => courses.length > 1).length;
        
        // Compter les salles utilisées
        const usedRooms = new Set(Object.values(currentRoomAssignments).filter(room => room !== 'Non assigné')).size;
        
        statsContent.innerHTML = `
            <div class="stat-item">
                <strong>Cours total:</strong> ${totalCourses}
            </div>
            <div class="stat-item">
                <strong>Cours assignés:</strong> ${assignedCourses}
            </div>
            <div class="stat-item ${unassignedCourses > 0 ? 'warning' : ''}">
                <strong>Non assignés:</strong> ${unassignedCourses}
            </div>
            <div class="stat-item ${conflictCount > 0 ? 'error' : ''}">
                <strong>Conflits salle/heure:</strong> ${conflictCount}
            </div>
            <div class="stat-item">
                <strong>Salles utilisées:</strong> ${usedRooms}/${planningData.rooms.length}
            </div>
        `;
    }
    
    // Réinitialiser le planning
    function resetPlanning() {
        if (planningData && confirm('Êtes-vous sûr de vouloir réinitialiser le planning aux assignations automatiques ?')) {
            currentAssignments = { ...planningData.assignments };
            renderPlanningGrid();
            updateStats();
            showAlert('Planning réinitialisé!', 'info');
        }
    }
    
    // Générer le planning Excel final
    async function generateFinalPlanning() {
        if (!planningData) {
            showAlert('Aucun planning chargé.', 'warning');
            return;
        }
        
        const targetDate = document.getElementById('target-date').value;
        
        showLoading('Génération du fichier Excel...');
        
        try {
            // Créer les assignments basés sur les positions actuelles des cours
            const finalAssignments = {};
            planningData.courses.forEach(course => {
                const slotKey = `${planningData.days[0]}_${course.time}`;
                if (!finalAssignments[slotKey]) {
                    finalAssignments[slotKey] = [];
                }
                finalAssignments[slotKey].push(course.id);
            });
            
            const response = await fetch('/api/planning-editor/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    assignments: finalAssignments,
                    room_assignments: currentRoomAssignments,
                    date: targetDate
                })
            });
            
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `planning_personnalise_${targetDate}.xlsx`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                showAlert('Planning Excel généré avec succès!', 'success');
            } else {
                const data = await response.json();
                throw new Error(data.error || 'Erreur lors de la génération');
            }
        } catch (error) {
            console.error('Erreur:', error);
            showAlert(`Erreur lors de la génération: ${error.message}`, 'danger');
        } finally {
            hideLoading();
        }
    }
    
    // Afficher l'overlay de chargement
    function showLoading(message = 'Chargement...') {
        document.getElementById('loading-message').textContent = message;
        document.getElementById('loading-overlay').style.display = 'flex';
    }
    
    // Masquer l'overlay de chargement
    function hideLoading() {
        document.getElementById('loading-overlay').style.display = 'none';
    }
    
    // Afficher une alerte
    function showAlert(message, type = 'info') {
        // Créer une alerte Bootstrap
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} alert-dismissible fade show`;
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        // Insérer au début du container
        const container = document.querySelector('.container-fluid');
        container.insertBefore(alert, container.firstChild);
        
        // Auto-supprimer après 5 secondes
        setTimeout(() => {
            if (alert && alert.parentElement) {
                alert.remove();
            }
        }, 5000);
    }
    
    // Fonction pour convertir une durée au format "1h25" ou "55min" en minutes
    function parseDurationToMinutes(duration) {
        if (typeof duration === 'string') {
            const hoursMatch = duration.match(/(\d+)h/);
            const minutesMatch = duration.match(/(\d+)min/);

            const hours = hoursMatch ? parseInt(hoursMatch[1], 10) : 0;
            const minutes = minutesMatch ? parseInt(minutesMatch[1], 10) : 0;

            return hours * 60 + minutes;
        }
        return typeof duration === 'number' ? duration : 0;
    }
</script>
{% endblock %}